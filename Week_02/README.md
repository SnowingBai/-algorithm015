## 哈希表、映射、集合
#### 哈希表（Hash table）
* 基础概念  
根据关键码值（key value）而直接进行访问的数据结构  
* 原理：通过关键码值映射列表中一个位置来访问记录，以加快查找的速度  
* 映射函数：散列函数（Hash Function）  
* 哈希表（散列表）：存放来记录的数组  
* 哈希碰撞：  
*[对于不同的要存储的数据，经过哈希函数之后得到一个相同的值]*
解决办法：  
**a. 依次向下面存占其他位置**  
**b. 增加一个维度，拉出一个链表来存（拉链式解决冲突法）**  
* 产生的问题：  
    哈希表的查询时间复杂度为O(1)，但有多个相同位置的元素时，变成链表，此时效率退化，查询时间复杂度为O(n)  

#### 树、二叉树、二叉搜索树
* 二叉树（Binary Tree）
复杂度：O(logn)  
子节点只有两个  
与图的差别：没有环  
*[Linked List是特殊化的Tree]*  
*[Tree是特殊化的Graph]*  
* 二叉树遍历  
a. 前序（Pre-order)：根 - 左 - 右  
b. 中序（In-order）：左 - 根 - 右（升序遍历）  
c. 后序（Post-order）：左 - 右 - 根  
* 二叉搜索树（Binary Search Tree）  
别名：二叉排序树、有序二叉树（Ordered Binary Tree）、排序二叉树（Sorted Binary Tree）  
概念：指一颗空树或具有下列性质的二叉树  
a. 左子树上所有结点的值均小于它的根结点的值  
b. 右子树上所有结点的值均大于它的根结点的值  
c. 以此类推：左、右子树也分别为二叉搜索树  
* 特殊情况：  
树退化成链表，查询复杂度退化为O(n)  

#### 堆和二叉树的实现和特性
* 堆（Heap）  
可以迅速找到一维数中最大**或**最小值得数据结构  
大顶堆（大根堆）：根节点最大的堆  
小顶堆（小根堆）：根节点最小的堆  
常见API及时间复杂度：  
find-max：O(1)  
delete-max：O(logn)  
insert(create)：O(logn) OR O(1)  
常见堆：二叉堆、斐波那契堆  

* 二叉堆性质
通过完全二叉树来实现（≠ 二叉搜索树）  
二叉堆（大顶）满足两个性质：  
a. 是一颗完全树  
b. 树种任意节点的值 ≥ 其子节点的值  

* 二叉堆实现的细节
一般通过“数组”实现  
架设“第一个元素”在数组中的索引为0，则父节点和子节点的位置关系如下：  
a. 索引为i的左孩子的索引：(2 * i + 1)  
b. 索引为i的右孩子的索引：(2 * i + 2)  
c. 索引为i的左孩子的索引：floor((i - 1) / 2)  

* Insert - O(logn)
新元素一律先插入到堆的尾部  
依次向上调整整个堆的结构（一直到根即可）  
对应HeapifyUp方法  

* Delete Max 删除堆顶
将堆尾元素替换到顶部（即大顶被替代删除掉）  
依次从根部向下调整整个堆的结构（一直到堆尾即可，每次与最大的子节点对比）  
对应HeapifyDown方法

* 补充
二叉堆是堆（优先队列priority-queue）的一种常见且简单的实现，并不是最优的实现

#### 图
* 图的属性：
 Graph(V, E)  
    a. V - vertex - 点  
    度：入度与出度（一个点连了几个边，如果无向，入度＝出度）  
    点与点之间：连通与否  
    b. E - edge - 边  
    有向 / 无向（单向线）  
    权重（边长）  
* 表示方法
邻连矩阵 & 邻连表
